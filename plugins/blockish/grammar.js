
/*
I converted grammar.txt into javascript.
This file represents:
- Which elements are valid children of each element
- Which elements are optional
- The order (if there is any) the children must appear

Currently it just prints out all the valid children of each element.

This file will also need to:
- denote which HTML element corresponds to each cnxml one
- Distinguish between which "optional" elements should be included in the autogenerated template
  (In a para everything is optional but shouldn't be created when a new template is)
- A set of "rules" for dealing with malformed HTML (graceful degredation of content)
*/

(function() {
  var ANY_BLOCK, ANY_INLINE, AUTO_INSERTED, BLOCK, BLOCKISH, G, INLINE, LABEL_TITLE, MEDIA_TEXT, ONLY_ANY_INLINE, ONLY_INLINE, ONLY_STRICTLY_INLINE, One, Opt, Or, PARA_INLINE_BLOCK, Rule, START, STRICTLY_INLINE, Seq, TITLE_BLOCK, Terminal, Zero, child, el2, element, flag, htmlToElement, invalidParents, key, n, parent, populate, rule, validParents, value, values, x, _, _i, _j, _k, _l, _len, _len2, _len3, _len4, _len5, _m, _ref, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7,
    __indexOf = Array.prototype.indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  G = {};

  AUTO_INSERTED = ['caption', 'problem', 'solution', 'statement', 'proof', 'item', 'para'];

  G.Rules = {};

  G.Root = '_root';

  populate = function(elements, rule) {
    var name, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = elements.length; _i < _len; _i++) {
      name = elements[_i];
      _results.push(G.Rules[name] = rule);
    }
    return _results;
  };

  Rule = (function() {

    function Rule() {}

    Rule.prototype.supports = function(name) {
      return false;
    };

    Rule.prototype.children = function() {
      return [];
    };

    Rule.prototype.templateChildren = function() {
      var child, template, _i, _len, _ref;
      template = [];
      _ref = this.children();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        if (__indexOf.call(AUTO_INSERTED, child) >= 0) template.push(child);
      }
      return template;
    };

    return Rule;

  })();

  Terminal = (function(_super) {

    __extends(Terminal, _super);

    function Terminal(name) {
      this.name = name;
    }

    Terminal.prototype.supports = function(name) {
      return this.name === name;
    };

    Terminal.prototype.children = function() {
      return [this.name];
    };

    Terminal.prototype.isValid = function(node) {
      return this.name === node.name;
    };

    Terminal.prototype.consumeChildren = function(childNodes) {
      var child;
      if (childNodes.length !== 0) {
        child = childNodes[0];
        if (this.name === child) return childNodes.splice(0, 1);
      }
    };

    return Terminal;

  })(Rule);

  Opt = (function(_super) {

    __extends(Opt, _super);

    function Opt() {
      Opt.__super__.constructor.apply(this, arguments);
    }

    return Opt;

  })(Terminal);

  Or = (function(_super) {

    __extends(Or, _super);

    function Or(rules) {
      var i, rule, _i, _len, _ref;
      this.rules = rules;
      i = 0;
      _ref = this.rules;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rule = _ref[_i];
        if (typeof rule === 'string') this.rules[i] = new Terminal(rule);
        i += 1;
      }
    }

    Or.prototype.supports = function(name) {
      var rule, _i, _len, _ref;
      _ref = this.rules;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rule = _ref[_i];
        if (rule.supports(name)) true;
      }
      return false;
    };

    Or.prototype.children = function() {
      var prod, ret, rule, _i, _j, _len, _len2, _ref, _ref2;
      ret = [];
      _ref = this.rules;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rule = _ref[_i];
        _ref2 = rule.children();
        for (_j = 0, _len2 = _ref2.length; _j < _len2; _j++) {
          prod = _ref2[_j];
          ret.push(prod);
        }
      }
      return ret;
    };

    Or.prototype.consumeChildren = function(childNodes) {
      var child, rule, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = childNodes.length; _i < _len; _i++) {
        child = childNodes[_i];
        _results.push((function() {
          var _j, _len2, _ref, _results2;
          _ref = this.rules;
          _results2 = [];
          for (_j = 0, _len2 = _ref.length; _j < _len2; _j++) {
            rule = _ref[_j];
            _results2.push(rule.consumeChildren(childNodes));
          }
          return _results2;
        }).call(this));
      }
      return _results;
    };

    return Or;

  })(Rule);

  Seq = (function(_super) {

    __extends(Seq, _super);

    function Seq() {
      Seq.__super__.constructor.apply(this, arguments);
    }

    Seq.prototype.consumeChildren = function(childNodes) {
      var child, rule, _i, _len, _ref, _results;
      _ref = this.rules;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rule = _ref[_i];
        _results.push((function() {
          var _j, _len2, _results2;
          _results2 = [];
          for (_j = 0, _len2 = childNodes.length; _j < _len2; _j++) {
            child = childNodes[_j];
            _results2.push(rule.consumeChildren(childNodes));
          }
          return _results2;
        })());
      }
      return _results;
    };

    return Seq;

  })(Or);

  One = (function(_super) {

    __extends(One, _super);

    function One(rule) {
      this.rule = rule;
      if (typeof this.rule === 'string') this.rule = new Terminal(this.rule);
    }

    One.prototype.supports = function(name) {
      return this.rule.supports(name);
    };

    One.prototype.children = function() {
      return this.rule.children();
    };

    One.prototype.consumeChildren = function(childNodes) {
      var child, _i, _len, _results;
      if (!childNodes) {
        console.log("");
        console.log("SIOUSRER");
      }
      _results = [];
      for (_i = 0, _len = childNodes.length; _i < _len; _i++) {
        child = childNodes[_i];
        _results.push(this.rule.consumeChildren(childNodes));
      }
      return _results;
    };

    return One;

  })(Opt);

  Zero = (function(_super) {

    __extends(Zero, _super);

    function Zero() {
      Zero.__super__.constructor.apply(this, arguments);
    }

    return Zero;

  })(One);

  START = new Or(['document']);

  LABEL_TITLE = new Seq([new Opt('label'), new Opt('title')]);

  BLOCKISH = new Or(['quote', 'preformat', 'list']);

  STRICTLY_INLINE = new Or(['emphasis', 'term', 'foreign', 'cite', 'span', 'sup', 'sub', 'code']);

  INLINE = new Or([STRICTLY_INLINE, BLOCKISH]);

  ANY_INLINE = new Or([INLINE, 'cite-title', 'note', 'media', 'footnote', 'link', 'newline', 'space']);

  ONLY_STRICTLY_INLINE = STRICTLY_INLINE;

  ONLY_INLINE = new One(INLINE);

  ONLY_ANY_INLINE = new Zero(ANY_INLINE);

  BLOCK = new Or([BLOCKISH, 'div', 'definition', 'example', 'figure', 'code', 'note', 'media', 'table', 'rule', 'equation', 'exercise']);

  PARA_INLINE_BLOCK = new Or(['para', ANY_INLINE, BLOCK]);

  ANY_BLOCK = new One(new Or(['section', BLOCK, 'para']));

  TITLE_BLOCK = new Seq([LABEL_TITLE, ANY_BLOCK]);

  MEDIA_TEXT = new Seq([new Opt('longdesc'), new Zero('param'), new Zero(new Or([STRICTLY_INLINE, 'cite-title', 'preformat', 'quote', 'note', 'list', 'object', 'image', 'audio', 'video', 'java-applet', 'flash', 'labview', 'text', 'download']))]);

  populate(['quote', 'note', 'item'], new Seq([new Opt('label'), ONLY_ANY_INLINE]));

  populate(['div', 'preformat', 'footnote', 'meaning'], new Seq([new Opt('title'), new One(PARA_INLINE_BLOCK)]));

  populate(['quote', 'note', 'commentary'], new Seq([LABEL_TITLE, new One(PARA_INLINE_BLOCK)]));

  populate(['quote', 'preformat'], new One(new Or(['para', ONLY_INLINE])));

  populate(['item', 'para'], ONLY_INLINE);

  populate(['term', 'foreign', 'cite', 'span', 'sup', 'sub', 'code', 'emphasis'], ONLY_STRICTLY_INLINE);

  populate(['section', 'example', 'problem', 'solution', 'statement', 'proof'], TITLE_BLOCK);

  populate(['preformat', 'title', 'label', 'span', 'cite', 'cite-title', 'link', 'emphasis', 'term', 'sub', 'sup', 'foreign', 'caption'], ONLY_ANY_INLINE);

  populate([G.Root], ANY_BLOCK);

  populate(['glossary'], new One('definition'));

  populate(['definition'], new Seq([new Opt('label'), 'term', new Or(['seealso', new One('meaning', new Zero('example')), new Opt('seealso')])]));

  populate(['seealso'], new Seq([new Opt('label'), new One('term')]));

  populate(['list'], new Seq([LABEL_TITLE, new One('item')]));

  populate(['rule'], new Seq([LABEL_TITLE, new One('statement'), new One(new Or(['proof', 'example']))]));

  populate(['exercise'], new Seq([LABEL_TITLE, 'problem', new Zero('solution'), new Zero('commentary')]));

  populate(['figure'], new Seq([LABEL_TITLE, new Or(['media', 'table', 'code', new One('subfigure')]), new Opt('caption')]));

  populate(['subfigure'], new Seq([LABEL_TITLE, new Or(['media', 'table', 'code']), new Opt('caption')]));

  populate(['item'], new Seq([new Opt('label'), new Zero(PARA_INLINE_BLOCK)]));

  populate(['para'], new One(new Or([ANY_INLINE, BLOCK])));

  populate(['code'], new One(ANY_INLINE));

  populate(['code'], new Seq([LABEL_TITLE, new One(ANY_INLINE), new Opt('caption')]));

  populate(['equation'], new Seq([LABEL_TITLE, new Or(['media'])]));

  G.Elements_INVERTED = {
    body: [G.Root],
    div: ['note', 'div', 'footnote', 'meaning', 'commentary', 'section', 'example', 'exercise', 'problem', 'solution', 'statement', 'proof', 'code', 'rule', 'equation'],
    span: ['preformat', 'term', 'foreign', 'cite', 'span', 'cite-title', 'caption', 'seealso', 'label'],
    dl: ['glossary'],
    dt: ['definition'],
    a: ['link'],
    p: ['para'],
    sub: ['sub'],
    sup: ['sup'],
    em: ['emphasis'],
    strong: ['emphasis'],
    ul: ['list'],
    ol: ['list'],
    li: ['item'],
    h1: ['title', 'label'],
    figure: ['figure', 'subfigure']
  };

  G.Elements = {};

  _ref = G.Elements_INVERTED;
  for (key in _ref) {
    values = _ref[key];
    for (_i = 0, _len = values.length; _i < _len; _i++) {
      value = values[_i];
      G.Elements[value] = key;
    }
  }

  G.AllElements = (function() {
    var _ref2, _results;
    _ref2 = G.Rules;
    _results = [];
    for (x in _ref2) {
      _ = _ref2[x];
      _results.push(x);
    }
    return _results;
  })();

  htmlToElement = function($el) {
    var name, tag, _j, _len2, _ref2;
    tag = $el.get(0).tagName.toLowerCase();
    if (tag in G.Elements_INVERTED) {
      if (G.Elements_INVERTED[tag].length === 1) {
        return G.Elements_INVERTED[tag][0];
      } else {
        _ref2 = G.Elements_INVERTED[tag];
        for (_j = 0, _len2 = _ref2.length; _j < _len2; _j++) {
          name = _ref2[_j];
          if ($el.hasClass(name)) return name;
        }
      }
    } else {
      console.log("Could not parse a " + tag);
      return null;
    }
  };

  G.Node = (function() {

    function Node($el, depth, name, children) {
      if (depth == null) depth = -1;
      this.name = name != null ? name : null;
      this.children = children != null ? children : [];
      if ($el) this.parseHtml($el, depth);
    }

    Node.prototype.parseHtml = function($el, depth) {
      var child, n, _j, _len2, _ref2, _ref3, _results;
      this.$el = $el;
      if (depth == null) depth = -1;
      this.name = htmlToElement(this.$el);
      if (this.name) {
        if (depth !== 0) {
          _ref2 = this.$el.children();
          _results = [];
          for (_j = 0, _len2 = _ref2.length; _j < _len2; _j++) {
            child = _ref2[_j];
            n = new G.Node();
            n.parseHtml($(child), (_ref3 = depth === -1) != null ? _ref3 : -{
              1: depth - 1
            });
            if (n.name) {
              _results.push(this.children.push(n));
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        }
      }
    };

    Node.prototype.allowsForA = function(name) {
      var child, children;
      if (this.name && this.children) {
        children = (function() {
          var _j, _len2, _ref2, _results;
          _ref2 = this.children;
          _results = [];
          for (_j = 0, _len2 = _ref2.length; _j < _len2; _j++) {
            child = _ref2[_j];
            _results.push(child.name);
          }
          return _results;
        }).call(this);
        switch (name) {
          case 'title':
            children.splice(0, 0, name);
            break;
          case 'label':
            children.splice(0, 0, name);
            break;
          default:
            children.push(name);
        }
        G.Rules[this.name].consumeChildren(children);
        return children.length === 0;
      }
    };

    return Node;

  })();

  if (typeof window !== "undefined" && window !== null) {
    window.Cnx = window.Cnx || {};
    window.Cnx.Grammar = G;
  } else {
    console.log("---------------------------------------------");
    console.log("Which elements will be autogenerated (optional/required)");
    console.log("  when a new element of this type is created?");
    console.log("---------------------------------------------");
    _ref2 = G.Rules;
    for (key in _ref2) {
      rule = _ref2[key];
      console.log("(Debug) Rule: " + key + ": " + (rule.templateChildren()));
    }
    console.log("---------------------------------------------");
    console.log("What are all the possible children of this element?");
    console.log("---------------------------------------------");
    _ref3 = G.Rules;
    for (key in _ref3) {
      rule = _ref3[key];
      console.log("(Debug) Rule: " + key + ": " + (rule.children()));
    }
    console.log("---------------------------------------------");
    console.log("Some unit tests on the grammar.");
    console.log("---------------------------------------------");
    n = new G.Node('list', [new G.Node('item'), new G.Node('item')]);
    rule = G.Rules[n.name];
    rule.consumeChildren(n.children);
    console.log("Expected: 0   Got: " + n.children.length);
    n = new G.Node('list', [new G.Node('item'), new G.Node('term')]);
    rule = G.Rules[n.name];
    rule.consumeChildren(n.children);
    console.log("Expected: 1   Got: " + n.children.length);
    console.log("---------------------------------------------");
    console.log("Which elements can be upconverted into other elements");
    console.log("  (assuming all of their child nodes are populated)");
    console.log("---------------------------------------------");
    _ref4 = G.AllElements;
    for (_j = 0, _len2 = _ref4.length; _j < _len2; _j++) {
      element = _ref4[_j];
      _ref5 = G.AllElements;
      for (_k = 0, _len3 = _ref5.length; _k < _len3; _k++) {
        el2 = _ref5[_k];
        if (element !== el2) {
          flag = false;
          _ref6 = G.Rules[element].children();
          for (_l = 0, _len4 = _ref6.length; _l < _len4; _l++) {
            child = _ref6[_l];
            if (__indexOf.call(G.Rules[el2].children(), child) < 0) flag = true;
          }
          if (!flag) {
            invalidParents = [];
            validParents = [];
            _ref7 = G.AllElements;
            for (_m = 0, _len5 = _ref7.length; _m < _len5; _m++) {
              parent = _ref7[_m];
              if (__indexOf.call(G.Rules[parent].children(), element) >= 0) {
                if (__indexOf.call(G.Rules[parent].children(), el2) >= 0) {
                  validParents.push(parent);
                } else {
                  invalidParents.push(parent);
                }
              }
            }
            if (validParents.length > 0) {
              if (invalidParents.length > 0) {
                if ((validParents.length - invalidParents.length >= 0 && invalidParents.length > 0) || validParents.length === 0) {
                  console.log("" + element + " > " + el2 + " except when in " + invalidParents);
                } else {
                  console.log("" + element + " > " + el2 + " ONLY when in " + validParents);
                }
              } else {
                console.log("" + element + " > " + el2);
              }
            }
          }
        }
      }
    }
  }

}).call(this);
