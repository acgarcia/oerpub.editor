
/*
I converted grammar.txt into javascript.
This file represents:
- Which elements are valid children of each element
- Which elements are optional
- The order (if there is any) the children must appear

Currently it just prints out all the valid children of each element.

This file will also need to:
- denote which HTML element corresponds to each cnxml one
- Distinguish between which "optional" elements should be included in the autogenerated template
  (In a para everything is optional but shouldn't be created when a new template is)
- A set of "rules" for dealing with malformed HTML (graceful degredation of content)
*/

(function() {
  var ANY_BLOCK, ANY_INLINE, AUTO_INSERTED, BLOCK, BLOCKISH, ELEMENTS, HTML_ELEMENTS, HTML_ELEMENTS_INVERTED, INLINE, LABEL_TITLE, MEDIA_TEXT, Node, ONLY_ANY_INLINE, ONLY_INLINE, ONLY_STRICTLY_INLINE, One, Opt, Or, PARA_INLINE_BLOCK, RULES, Rule, START, STRICTLY_INLINE, Seq, TITLE_BLOCK, Terminal, Zero, child, el2, element, flag, htmlToElement, invalidParents, key, n, parent, populate, rule, validParents, value, values, x, _, _i, _j, _k, _l, _len, _len2, _len3, _len4, _len5, _m, _ref,
    __indexOf = Array.prototype.indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  AUTO_INSERTED = ['title', 'caption', 'problem', 'solution', 'statement', 'proof', 'item', 'para'];

  RULES = {};

  populate = function(elements, rule) {
    var name, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = elements.length; _i < _len; _i++) {
      name = elements[_i];
      _results.push(RULES[name] = rule);
    }
    return _results;
  };

  Rule = (function() {

    function Rule() {}

    Rule.prototype.supports = function(name) {
      return false;
    };

    Rule.prototype.children = function() {
      return [];
    };

    Rule.prototype.templateChildren = function() {
      var child, template, _i, _len, _ref;
      template = [];
      _ref = this.children();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        if (__indexOf.call(AUTO_INSERTED, child) >= 0) template.push(child);
      }
      return template;
    };

    return Rule;

  })();

  Terminal = (function(_super) {

    __extends(Terminal, _super);

    function Terminal(name) {
      this.name = name;
    }

    Terminal.prototype.supports = function(name) {
      return this.name === name;
    };

    Terminal.prototype.children = function() {
      return [this.name];
    };

    Terminal.prototype.isValid = function(node) {
      return this.name === node.name;
    };

    Terminal.prototype.consumeChildren = function(childNodes) {
      var child, rule;
      child = childNodes[0];
      if (this.name === child.name) {
        rule = RULES[this.name];
        rule.consumeChildren(child.children);
        if (child.children.length === 0) return childNodes.splice(0, 1);
      }
    };

    return Terminal;

  })(Rule);

  Opt = (function(_super) {

    __extends(Opt, _super);

    function Opt() {
      Opt.__super__.constructor.apply(this, arguments);
    }

    return Opt;

  })(Terminal);

  Or = (function(_super) {

    __extends(Or, _super);

    function Or(rules) {
      var i, rule, _i, _len, _ref;
      this.rules = rules;
      i = 0;
      _ref = this.rules;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rule = _ref[_i];
        if (typeof rule === 'string') this.rules[i] = new Terminal(rule);
        i += 1;
      }
    }

    Or.prototype.supports = function(name) {
      var rule, _i, _len, _ref;
      _ref = this.rules;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rule = _ref[_i];
        if (rule.supports(name)) true;
      }
      return false;
    };

    Or.prototype.children = function() {
      var prod, ret, rule, _i, _j, _len, _len2, _ref, _ref2;
      ret = [];
      _ref = this.rules;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rule = _ref[_i];
        _ref2 = rule.children();
        for (_j = 0, _len2 = _ref2.length; _j < _len2; _j++) {
          prod = _ref2[_j];
          ret.push(prod);
        }
      }
      return ret;
    };

    Or.prototype.consumeChildren = function(childNodes) {
      var child, rule, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = childNodes.length; _i < _len; _i++) {
        child = childNodes[_i];
        _results.push((function() {
          var _j, _len2, _ref, _results2;
          _ref = this.rules;
          _results2 = [];
          for (_j = 0, _len2 = _ref.length; _j < _len2; _j++) {
            rule = _ref[_j];
            _results2.push(rule.consumeChildren(childNodes));
          }
          return _results2;
        }).call(this));
      }
      return _results;
    };

    return Or;

  })(Rule);

  Seq = (function(_super) {

    __extends(Seq, _super);

    function Seq() {
      Seq.__super__.constructor.apply(this, arguments);
    }

    Seq.prototype.consumeChildren = function(childNodes) {
      var child, rule, _i, _len, _ref, _results;
      _ref = this.rules;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        rule = _ref[_i];
        _results.push((function() {
          var _j, _len2, _results2;
          _results2 = [];
          for (_j = 0, _len2 = childNodes.length; _j < _len2; _j++) {
            child = childNodes[_j];
            _results2.push(rule.consumeChildren(childNodes));
          }
          return _results2;
        })());
      }
      return _results;
    };

    return Seq;

  })(Or);

  One = (function(_super) {

    __extends(One, _super);

    function One(rule) {
      this.rule = rule;
      if (typeof this.rule === 'string') this.rule = new Terminal(this.rule);
    }

    One.prototype.supports = function(name) {
      return this.rule.supports(name);
    };

    One.prototype.children = function() {
      return this.rule.children();
    };

    One.prototype.consumeChildren = function(childNodes) {
      var child, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = childNodes.length; _i < _len; _i++) {
        child = childNodes[_i];
        _results.push(this.rule.consumeChildren(childNodes));
      }
      return _results;
    };

    return One;

  })(Opt);

  Zero = (function(_super) {

    __extends(Zero, _super);

    function Zero() {
      Zero.__super__.constructor.apply(this, arguments);
    }

    return Zero;

  })(One);

  START = new Or(['document']);

  LABEL_TITLE = new Seq([new Opt('label'), new Opt('title')]);

  BLOCKISH = new Or(['quote', 'preformat', 'list']);

  STRICTLY_INLINE = new Or(['emphasis', 'term', 'foreign', 'cite', 'span', 'sup', 'sub', 'code']);

  INLINE = new Or([STRICTLY_INLINE, BLOCKISH]);

  ANY_INLINE = new Or([INLINE, 'cite-title', 'note', 'media', 'footnote', 'link', 'newline', 'space']);

  ONLY_STRICTLY_INLINE = STRICTLY_INLINE;

  ONLY_INLINE = new One(INLINE);

  ONLY_ANY_INLINE = new Zero(ANY_INLINE);

  BLOCK = new Or([BLOCKISH, 'div', 'definition', 'example', 'figure', 'code', 'note', 'media', 'table', 'rule', 'equation', 'exercise']);

  PARA_INLINE_BLOCK = new Or(['para', ANY_INLINE, BLOCK]);

  ANY_BLOCK = new One(new Or(['section', BLOCK, 'para']));

  TITLE_BLOCK = new Seq([LABEL_TITLE, ANY_BLOCK]);

  MEDIA_TEXT = new Seq([new Opt('longdesc'), new Zero('param'), new Zero(new Or([STRICTLY_INLINE, 'cite-title', 'preformat', 'quote', 'note', 'list', 'object', 'image', 'audio', 'video', 'java-applet', 'flash', 'labview', 'text', 'download']))]);

  populate(['quote', 'note', 'item'], new Seq([new Opt('label'), ONLY_ANY_INLINE]));

  populate(['div', 'preformat', 'footnote', 'meaning'], new Seq([new Opt('title'), new One(PARA_INLINE_BLOCK)]));

  populate(['quote', 'note', 'commentary'], new Seq([LABEL_TITLE, new One(PARA_INLINE_BLOCK)]));

  populate(['quote', 'preformat'], new One(new Or(['para', ONLY_INLINE])));

  populate(['item', 'para'], ONLY_INLINE);

  populate(['term', 'foreign', 'cite', 'span', 'sup', 'sub', 'code', 'emphasis'], ONLY_STRICTLY_INLINE);

  populate(['section', 'example', 'problem', 'solution', 'statement', 'proof'], TITLE_BLOCK);

  populate(['preformat', 'title', 'label', 'span', 'cite', 'cite-title', 'link', 'emphasis', 'term', 'sub', 'sup', 'foreign', 'caption'], ONLY_ANY_INLINE);

  populate(['glossary'], new One('definition'));

  populate(['definition'], new Seq([new Opt('label'), 'term', new Or(['seealso', new One('meaning', new Zero('example')), new Opt('seealso')])]));

  populate(['seealso'], new Seq([new Opt('label'), new One('term')]));

  populate(['list'], new Seq([LABEL_TITLE, new One('item')]));

  populate(['rule'], new Seq([LABEL_TITLE, new One('statement'), new One(new Or(['proof', 'example']))]));

  populate(['exercise'], new Seq([LABEL_TITLE, 'problem', new Zero('solution'), new Zero('commentary')]));

  populate(['figure'], new Seq([LABEL_TITLE, new Or(['media', 'table', 'code', new One('subfigure')]), new Opt('caption')]));

  populate(['subfigure'], new Seq([LABEL_TITLE, new Or(['media', 'table', 'code']), new Opt('caption')]));

  populate(['item'], new Seq([new Opt('label'), new Zero(PARA_INLINE_BLOCK)]));

  populate(['para'], new One(new Or([ANY_INLINE, BLOCK])));

  populate(['code'], new One(ANY_INLINE));

  populate(['code'], new Seq([LABEL_TITLE, new One(ANY_INLINE), new Opt('caption')]));

  populate(['equation'], new Seq([LABEL_TITLE, new Or(['media'])]));

  HTML_ELEMENTS_INVERTED = {
    div: ['note', 'div', 'footnote', 'meaning', 'commentary', 'section', 'example', 'exercise', 'problem', 'solution', 'statement', 'proof', 'code', 'rule', 'equation'],
    span: ['preformat', 'term', 'foreign', 'cite', 'span', 'cite-title', 'caption', 'seealso', 'label'],
    dl: ['glossary'],
    dt: ['definition'],
    a: ['link'],
    p: ['para'],
    sub: ['sub'],
    sup: ['sup'],
    em: ['emphasis'],
    strong: ['emphasis'],
    ul: ['list'],
    ol: ['list'],
    li: ['item'],
    h1: ['title', 'label'],
    figure: ['figure', 'subfigure']
  };

  HTML_ELEMENTS = {};

  for (key in HTML_ELEMENTS_INVERTED) {
    values = HTML_ELEMENTS_INVERTED[key];
    for (_i = 0, _len = values.length; _i < _len; _i++) {
      value = values[_i];
      HTML_ELEMENTS[value] = key;
    }
  }

  ELEMENTS = (function() {
    var _results;
    _results = [];
    for (x in RULES) {
      _ = RULES[x];
      _results.push(x);
    }
    return _results;
  })();

  htmlToElement = function($el) {
    var name, tag, _j, _len2, _ref;
    tag = $el.get(0).tagName;
    if (__indexOf.call(HTML_ELEMENTS_INVERTED, tag) >= 0) {
      if (HTML_ELEMENTS_INVERTED[tag].length === 1) {
        return HTML_ELEMENTS_INVERTED[tag];
      } else {
        _ref = HTML_ELEMENTS_INVERTED[tag];
        for (_j = 0, _len2 = _ref.length; _j < _len2; _j++) {
          name = _ref[_j];
          if ($el.hasClass(name)) return name;
        }
      }
    } else {
      return null;
    }
  };

  Node = (function() {

    function Node(name, children) {
      this.name = name != null ? name : null;
      this.children = children != null ? children : [];
    }

    Node.prototype.parseHtml = function($el) {
      var child, n, _j, _len2, _ref, _results;
      this.$el = $el;
      this.name = htmlToElement(this.$el);
      _ref = this.$el.children();
      _results = [];
      for (_j = 0, _len2 = _ref.length; _j < _len2; _j++) {
        child = _ref[_j];
        n = new Node();
        n.parseHtml(child);
        _results.push(this.children.push(n));
      }
      return _results;
    };

    return Node;

  })();

  if (typeof window !== "undefined" && window !== null) {
    window.Cnx = window.Cnx || {};
    window.Cnx.Grammar = {
      AllElements: ELEMENTS,
      Rules: RULES,
      Elements: HTML_ELEMENTS
    };
  } else {
    console.log("---------------------------------------------");
    console.log("Which elements will be autogenerated (optional/required)");
    console.log("  when a new element of this type is created?");
    console.log("---------------------------------------------");
    for (key in RULES) {
      rule = RULES[key];
      console.log("(Debug) Rule: " + key + ": " + (rule.templateChildren()));
    }
    console.log("---------------------------------------------");
    console.log("What are all the possible children of this element?");
    console.log("---------------------------------------------");
    for (key in RULES) {
      rule = RULES[key];
      console.log("(Debug) Rule: " + key + ": " + (rule.children()));
    }
    console.log("---------------------------------------------");
    console.log("Some unit tests on the grammar.");
    console.log("---------------------------------------------");
    n = new Node('list', [new Node('item'), new Node('item')]);
    rule = RULES[n.name];
    rule.consumeChildren(n.children);
    console.log("Expected: 0   Got: " + n.children.length);
    n = new Node('list', [new Node('item'), new Node('term')]);
    rule = RULES[n.name];
    rule.consumeChildren(n.children);
    console.log("Expected: 1   Got: " + n.children.length);
    console.log("---------------------------------------------");
    console.log("Which elements can be upconverted into other elements");
    console.log("  (assuming all of their child nodes are populated)");
    console.log("---------------------------------------------");
    for (_j = 0, _len2 = ELEMENTS.length; _j < _len2; _j++) {
      element = ELEMENTS[_j];
      for (_k = 0, _len3 = ELEMENTS.length; _k < _len3; _k++) {
        el2 = ELEMENTS[_k];
        if (element !== el2) {
          flag = false;
          _ref = RULES[element].children();
          for (_l = 0, _len4 = _ref.length; _l < _len4; _l++) {
            child = _ref[_l];
            if (__indexOf.call(RULES[el2].children(), child) < 0) flag = true;
          }
          if (!flag) {
            invalidParents = [];
            validParents = [];
            for (_m = 0, _len5 = ELEMENTS.length; _m < _len5; _m++) {
              parent = ELEMENTS[_m];
              if (__indexOf.call(RULES[parent].children(), element) >= 0) {
                if (__indexOf.call(RULES[parent].children(), el2) >= 0) {
                  validParents.push(parent);
                } else {
                  invalidParents.push(parent);
                }
              }
            }
            if (validParents.length > 0) {
              if (invalidParents.length > 0) {
                if ((validParents.length - invalidParents.length >= 0 && invalidParents.length > 0) || validParents.length === 0) {
                  console.log("" + element + " > " + el2 + " except when in " + invalidParents);
                } else {
                  console.log("" + element + " > " + el2 + " ONLY when in " + validParents);
                }
              } else {
                console.log("" + element + " > " + el2);
              }
            }
          }
        }
      }
    }
  }

}).call(this);
